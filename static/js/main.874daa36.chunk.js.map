{"version":3,"sources":["common/snake.ts","utils/array.ts","utils/segments.ts","utils/intersection.ts","utils/snake.ts","utils/food.ts","Main/S/index.tsx","utils/listeners.ts","Main/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Direction","isArrayEqual","array1","array2","Array","isArray","length","every","val","index","addItemToRotationList","head","rotateList","direction","push","position","rect","attrs","x","y","segmentsPassed","addSegment","segmentList","layer","segment","Konva","Rect","width","height","fill","stroke","strokeWidth","add","lastRect","doesHeadIntersectWithSegment","segmentRect","animateSnake","foodRect","anim","Animation","frame","rotationList","segments","forEach","rotation","updateSegmentRotationDirection","updateSegment","headRect","checkHeadFoodIntersection","Math","floor","random","window","innerWidth","innerHeight","repositionFood","find","checkHeadSegmentIntersection","stop","filter","start","S","food","makeFood","headRef","useRef","foodRef","layerRef","rotateRef","segmentRef","useEffect","current","addEventListener","code","removeSnakeKeyPressListener","addSnakeKeyPressListener","ref","Main","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.874daa36.chunk.js","sourcesContent":["export const Direction = {\n    Up: [0,-1],\n    Down: [0,1],\n    Left: [-1,0],\n    Right: [1,0]\n}","export const isArrayEqual = (array1: Array<number>, array2: Array<number>) => {\n  return (\n    Array.isArray(array1) &&\n    Array.isArray(array2) &&\n    array1.length === array2.length &&\n    array1.every((val, index) => val === array2[index])\n  );\n};\n\nexport const addItemToRotationList = (\n  head: any,\n  rotateList: Array<any>,\n  direction: Array<number>\n) => {\n  head.direction = direction;\n  rotateList.push({\n    position: [head.rect.attrs.x, head.rect.attrs.y],\n    direction: direction,\n    segmentsPassed: 0,\n  });\n};\n","import Konva from \"konva\";\n\nexport const addSegment = (\n  segmentList: Array<any>,\n  layer: Konva.Layer | null\n) => {\n  if (!layer) return;\n  if (!segmentList.length) {\n    let rect = new Konva.Rect({\n      x: 50,\n      y: 0,\n      width: 50,\n      height: 50,\n      fill: \"#00D2FF\",\n      stroke: \"black\",\n      strokeWidth: 0.5,\n    });\n    const segment = { rect, direction: [1, 0] };\n    segmentList.push(segment);\n    layer.add(segment.rect);\n    return;\n  }\n  const { rect: lastRect, direction } = segmentList[segmentList.length - 1];\n  let rect = new Konva.Rect({\n    x: lastRect.attrs.x - direction[0] * lastRect.attrs.width,\n    y: lastRect.attrs.y + direction[1] * lastRect.attrs.height,\n    width: 50,\n    height: 50,\n    fill: \"#00D2FF\",\n    stroke: \"black\",\n    strokeWidth: 0.5,\n  });\n  const segment = { rect, direction };\n  segmentList.push(segment);\n  layer.add(segment.rect); //add segment to\n};\n\n//update position of segment\nexport const updateSegment = (segment:any)=>{\n  segment.rect.x(segment.rect.attrs.x + segment.direction[0]*2);\n  segment.rect.y(segment.rect.attrs.y + segment.direction[1]*2);\n};\n\nexport const updateSegmentRotationDirection = (segment:any,rotation:any) =>{ \n  if (\n    segment.rect.attrs.x === rotation.position[0] &&\n    segment.rect.attrs.y === rotation.position[1]\n  ) {\n    rotation.segmentsPassed = rotation.segmentsPassed + 1;\n    segment.direction = rotation.direction;\n  }\n}\n\nexport const updateRotationList = (rotationList: any, segments: number) => { //remove from rotation list when all segments passed the point\n  rotationList = rotationList.filter(\n    ({ segmentsPassed }: any) => segmentsPassed < segments\n  );\n};\n","export const checkHeadSegmentIntersection = (\n  segmentList: Array<any>,\n  head: any\n) => {\n  const intersection = segmentList.find(({ rect }) =>\n    doesHeadIntersectWithSegment(head, rect)\n  );\n  return !!intersection;\n};\n\nconst doesHeadIntersectWithSegment = (head: any, segmentRect: any) => {\n  return false;\n};\n\nexport const checkHeadFoodIntersection = (headRect: any, foodRect: any) => {\n  return (\n    headRect.attrs.x < foodRect.attrs.x + 50 &&\n    headRect.attrs.x + 50 > foodRect.attrs.x &&\n    headRect.attrs.y < foodRect.attrs.y + 50 &&\n    50 + headRect.attrs.y > foodRect.attrs.y\n  );\n};\n","import Konva from \"konva\";\nimport { repositionFood } from \"./food\";\nimport {\n  checkHeadFoodIntersection,\n  checkHeadSegmentIntersection,\n} from \"./intersection\";\nimport {\n  addSegment,\n  updateRotationList,\n  updateSegment,\n  updateSegmentRotationDirection,\n} from \"./segments\";\nexport const makeHead = () => {\n  let rect = new Konva.Rect({\n    x: 100,\n    y: 0,\n    width: 50,\n    height: 50,\n    fill: \"#00D2FF\",\n    stroke: \"black\",\n    strokeWidth: 0.5,\n  });\n\n  const direction = [1, 0];\n\n  return { rect, direction };\n};\n\nexport const animateSnake = ({\n  foodRect,\n  head,\n  layer,\n  segmentList,\n  rotateList,\n}: any) => {\n  var anim = new Konva.Animation((frame: any) => {\n    head.rect.x(head.rect.attrs.x + head.direction[0]*2);\n    head.rect.y(head.rect.attrs.y + head.direction[1]*2);\n    segmentList.forEach((segment: any) => {\n      rotateList.forEach((rotation: any) => {\n        updateSegmentRotationDirection(segment, rotation);\n      });\n      updateSegment(segment);\n      if (checkHeadFoodIntersection(head.rect, foodRect)){\n        repositionFood(foodRect);\n        addSegment(segmentList,layer)\n      }\n      if (checkHeadSegmentIntersection(segmentList, head.rect)) anim.stop();\n    });\n    updateRotationList(rotateList, segmentList.length - 1);\n  }, layer);\n  anim.start();\n};\n","import Konva from \"konva\";\n\nexport const makeFood = () => {\n  let x = Math.floor(Math.random() * (window.innerWidth - 50));\n  let y = Math.floor(Math.random() * (window.innerHeight - 50));\n  let rect = new Konva.Rect({\n    x,\n    y,\n    width: 50,\n    height: 50,\n    fill: \"#DC143C\",\n    stroke: \"black\",\n    strokeWidth: 0.5,\n  });\n  return rect;\n};\n\nexport const repositionFood = (foodRect:any) =>{\n    let x = Math.floor(Math.random() * (window.innerWidth - 50));\n    let y = Math.floor(Math.random() * (window.innerHeight - 50));\n    foodRect.x(x)\n    foodRect.y(y)\n}","import Konva from \"konva\";\nimport { useEffect, useRef } from \"react\";\nimport { Layer } from \"react-konva\";\nimport { makeFood } from \"../../utils/food\";\nimport { addSnakeKeyPressListener, removeSnakeKeyPressListener } from \"../../utils/listeners\";\nimport { addSegment } from \"../../utils/segments\";\nimport { animateSnake, makeHead } from \"../../utils/snake\";\n\nconst S = () => {\n  const head = makeHead();\n  const food = makeFood();\n  const headRef = useRef<any>(head);\n  const foodRef = useRef<Konva.Rect>(food);\n  const layerRef = useRef<Konva.Layer>(null);\n  const rotateRef = useRef<Array<any>>([]); //list of points where segments rotate\n  const segmentRef = useRef<Array<any>>([]);\n\n\n  useEffect(() => {\n    const { current: head } = headRef;\n    const { current: foodRect } = foodRef;\n    const { current: layer } = layerRef;\n    const { current: segmentList } = segmentRef;\n    const { current: rotateList } = rotateRef;\n    layer?.add(head.rect);\n    layer?.add(foodRect)\n    addSegment(segmentList,layer)\n    animateSnake({foodRect,head,layer,segmentList,rotateList});\n    return removeSnakeKeyPressListener(headRef,rotateRef)\n  });\n\n  addSnakeKeyPressListener(headRef,rotateRef);\n\n  return <Layer ref={layerRef} />;\n};\n\nexport default S;\n","import { Direction } from \"../common/snake\";\nimport { addItemToRotationList, isArrayEqual } from \"./array\";\n\nexport const addSnakeKeyPressListener = (headRef: any, rotateRef: any) => {\n  window.addEventListener(\"keypress\", ({ code }) => {\n    const { current: head } = headRef;\n    const { current: rotateList } = rotateRef;\n    if (\n      isArrayEqual(head.direction, Direction.Left) ||\n      isArrayEqual(head.direction, Direction.Right)\n    ) {\n      if (code === \"KeyS\") {\n        addItemToRotationList(head, rotateList, Direction.Down);\n      } else if (code === \"KeyW\") {\n        addItemToRotationList(head, rotateList, Direction.Up);\n      }\n    } else if (\n      isArrayEqual(head.direction, Direction.Up) ||\n      isArrayEqual(head.direction, Direction.Down)\n    ) {\n      if (code === \"KeyA\") {\n        addItemToRotationList(head, rotateList, Direction.Left);\n      } else if (code === \"KeyD\") {\n        addItemToRotationList(head, rotateList, Direction.Right);\n      }\n    }\n  });\n};\n\nexport const removeSnakeKeyPressListener = (headRef: any, rotateRef: any) => {\n  window.addEventListener(\"keypress\", ({ code }) => {\n    const { current: head } = headRef;\n    const { current: rotateList } = rotateRef;\n    if (\n      isArrayEqual(head.direction, Direction.Left) ||\n      isArrayEqual(head.direction, Direction.Right)\n    ) {\n      if (code === \"KeyS\") {\n        addItemToRotationList(head, rotateList, Direction.Down);\n      } else if (code === \"KeyW\") {\n        addItemToRotationList(head, rotateList, Direction.Up);\n      }\n    } else if (\n      isArrayEqual(head.direction, Direction.Up) ||\n      isArrayEqual(head.direction, Direction.Down)\n    ) {\n      if (code === \"KeyA\") {\n        addItemToRotationList(head, rotateList, Direction.Left);\n      } else if (code === \"KeyD\") {\n        addItemToRotationList(head, rotateList, Direction.Right);\n      }\n    }\n  });\n};\n","import { Stage } from \"react-konva\"\nimport S from \"./S\";\n\nconst Main = () => {\n    return <Stage width={window.innerWidth} height={window.innerHeight}> \n    <S/>\n    </Stage>\n}\n\nexport default Main;","import './App.css';\nimport Main from './Main';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Main/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}