{"version":3,"sources":["utils/segments.ts","utils/intersection.ts","utils/snake.ts","utils/food.ts","Main/S/index.tsx","utils/listeners.ts","Main/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["addSegment","segmentList","layer","length","segment","rect","Konva","Rect","x","y","width","height","fill","stroke","strokeWidth","direction","push","add","lastRect","attrs","doesHeadIntersectWithSegment","head","animateSnake","foodRect","rotateList","anim","Animation","frame","rotationList","segments","forEach","rotation","position","segmentsPassed","updateSegmentRotationDirection","updateSegment","headRect","checkHeadFoodIntersection","Math","floor","random","window","innerWidth","innerHeight","repositionFood","find","checkHeadSegmentIntersection","stop","filter","start","S","Shape","sceneFunc","context","shape","beginPath","moveTo","lineTo","closePath","fillStrokeShape","offset","food","makeFood","headRef","useRef","foodRef","layerRef","rotateRef","segmentRef","useEffect","current","removeEventListener","code","rotate","removeSnakeKeyPressListener","addEventListener","addSnakeKeyPressListener","ref","Main","App","className","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.111ddec2.chunk.js","sourcesContent":["import Konva from \"konva\";\n\nexport const addSegment = (\n  segmentList: Array<any>,\n  layer: Konva.Layer | null\n) => {\n  if (!layer) return;\n  if (!segmentList.length) {\n    let rect = new Konva.Rect({\n      x: 50,\n      y: 0,\n      width: 50,\n      height: 50,\n      fill: \"#00D2FF\",\n      stroke: \"black\",\n      strokeWidth: 0.5,\n    });\n    const segment = { rect, direction: [1, 0] };\n    segmentList.push(segment);\n    layer.add(segment.rect);\n    return;\n  }\n  const { rect: lastRect, direction } = segmentList[segmentList.length - 1];\n  let rect = new Konva.Rect({\n    x: lastRect.attrs.x - direction[0] * lastRect.attrs.width,\n    y: lastRect.attrs.y + direction[1] * lastRect.attrs.height,\n    width: 50,\n    height: 50,\n    fill: \"#00D2FF\",\n    stroke: \"black\",\n    strokeWidth: 0.5,\n  });\n  const segment = { rect, direction };\n  segmentList.push(segment);\n  layer.add(segment.rect); //add segment to\n};\n\n//update position of segment\nexport const updateSegment = (segment:any)=>{\n  segment.rect.x(segment.rect.attrs.x + segment.direction[0]*2);\n  segment.rect.y(segment.rect.attrs.y - segment.direction[1]*2);\n};\n\nexport const updateSegmentRotationDirection = (segment:any,rotation:any) =>{ \n  if (\n    segment.rect.attrs.x === rotation.position[0] &&\n    segment.rect.attrs.y === rotation.position[1]\n  ) {\n    rotation.segmentsPassed = rotation.segmentsPassed + 1;\n    segment.direction = rotation.direction;\n  }\n}\n\nexport const updateRotationList = (rotationList: any, segments: number) => { //remove from rotation list when all segments passed the point\n  rotationList = rotationList.filter(\n    ({ segmentsPassed }: any) => segmentsPassed < segments\n  );\n};\n","export const checkHeadSegmentIntersection = (\n  segmentList: Array<any>,\n  head: any\n) => {\n  const intersection = segmentList.find((segment) => doesHeadIntersectWithSegment(head,segment));\n  return !!intersection\n};\n\nconst doesHeadIntersectWithSegment = (head: any, segment: any) => {\n  return (\n    head.attrs.x > segment.rect.attrs.x &&\n    head.attrs.x < segment.rect.attrs.x + 50 &&\n    head.attrs.y > segment.rect.attrs.y &&\n    head.attrs.y < segment.rect.attrs.y + 50\n  );\n}\n\nexport const checkHeadFoodIntersection = (headRect:any,foodRect:any) =>{\n  return (\n    headRect.attrs.x > foodRect.attrs.x &&\n    headRect.attrs.x < foodRect.attrs.x + 50 &&\n    headRect.attrs.y > foodRect.attrs.y &&\n    headRect.attrs.y < foodRect.attrs.y + 50\n  )\n}\n","import Konva from \"konva\";\nimport { repositionFood } from \"./food\";\nimport {\n  checkHeadFoodIntersection,\n  checkHeadSegmentIntersection,\n} from \"./intersection\";\nimport {\n  addSegment,\n  updateRotationList,\n  updateSegment,\n  updateSegmentRotationDirection,\n} from \"./segments\";\nexport const makeHead = () => {\n  var rect = new Konva.Shape({\n    sceneFunc: (context, shape) => {\n      context.beginPath();\n      context.moveTo(50, 25);\n      context.lineTo(25, 50);\n      context.lineTo(0, 50);\n      context.lineTo(0, 0);\n      context.lineTo(25, 0);\n      context.closePath();\n      context.fillStrokeShape(shape);\n    },\n    fill: \"#00D2FF\",\n    stroke: \"black\",\n    strokeWidth: 1,\n    x: 125,\n    y: 25,\n    offset: {\n      x: 25,\n      y: 25,\n    },\n  });\n\n  const direction = [1, 0];\n\n  return { rect, direction };\n};\n\nexport const animateSnake = ({\n  foodRect,\n  head,\n  layer,\n  segmentList,\n  rotateList,\n}: any) => {\n  var anim = new Konva.Animation((frame: any) => {\n    head.rect.x(head.rect.attrs.x + head.direction[0]*2);\n    head.rect.y(head.rect.attrs.y - head.direction[1]*2);\n    segmentList.forEach((segment: any) => {\n      rotateList.forEach((rotation: any) => {\n        updateSegmentRotationDirection(segment, rotation);\n      });\n      updateSegment(segment);\n      if (checkHeadFoodIntersection(head.rect, foodRect)){\n        repositionFood(foodRect);\n        addSegment(segmentList,layer)\n      }\n      if (checkHeadSegmentIntersection(segmentList, head.rect)) anim.stop();\n    });\n    updateRotationList(rotateList, segmentList.length - 1);\n  }, layer);\n  anim.start();\n};\n","import Konva from \"konva\";\n\nexport const makeFood = () => {\n  let x = Math.floor(Math.random() * (window.innerWidth - 50));\n  let y = Math.floor(Math.random() * (window.innerHeight - 50));\n  let rect = new Konva.Rect({\n    x,\n    y,\n    width: 50,\n    height: 50,\n    fill: \"#DC143C\",\n    stroke: \"black\",\n    strokeWidth: 0.5,\n  });\n  return rect;\n};\n\nexport const repositionFood = (foodRect:any) =>{\n    let x = Math.floor(Math.random() * (window.innerWidth - 50));\n    let y = Math.floor(Math.random() * (window.innerHeight - 50));\n    foodRect.x(x)\n    foodRect.y(y)\n}","import Konva from \"konva\";\nimport { useEffect, useRef } from \"react\";\nimport { Layer } from \"react-konva\";\nimport { makeFood } from \"../../utils/food\";\nimport { addSnakeKeyPressListener, removeSnakeKeyPressListener } from \"../../utils/listeners\";\nimport { addSegment } from \"../../utils/segments\";\nimport { animateSnake, makeHead } from \"../../utils/snake\";\n\nconst S = () => {\n  const head = makeHead();\n  const food = makeFood();\n  const headRef = useRef<any>(head);\n  const foodRef = useRef<Konva.Rect>(food);\n  const layerRef = useRef<Konva.Layer>(null);\n  const rotateRef = useRef<Array<any>>([]); //list of points where segments rotate\n  const segmentRef = useRef<Array<any>>([]);\n\n\n  useEffect(() => {\n    const { current: head } = headRef;\n    const { current: foodRect } = foodRef;\n    const { current: layer } = layerRef;\n    const { current: segmentList } = segmentRef;\n    const { current: rotateList } = rotateRef;\n    layer?.add(head.rect);\n    layer?.add(foodRect)\n    addSegment(segmentList,layer)\n    animateSnake({foodRect,head,layer,segmentList,rotateList});\n    return removeSnakeKeyPressListener(headRef,rotateRef)\n  });\n\n  addSnakeKeyPressListener(headRef,rotateRef);\n\n  return <Layer ref={layerRef} />;\n};\n\nexport default S;\n","export const addSnakeKeyPressListener = (headRef: any, rotateRef: any) => {\n  window.addEventListener(\"keypress\", ({ code }) => {\n    const { current: head } = headRef;\n    const { current: rotateList } = rotateRef;\n    if (code === \"KeyW\") {\n      if (\n        (head.direction[0] === 1 && head.direction[1] === 0) ||\n        (head.direction[0] === -1 && head.direction[1] === 0)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [0, 1],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[0] * -90);\n        head.direction = [0, 1];\n      }\n    } else if (code === \"KeyS\") {\n      if (\n        (head.direction[0] === 1 && head.direction[1] === 0) ||\n        (head.direction[0] === -1 && head.direction[1] === 0)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [0, -1],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[0] * 90);\n        head.direction = [0, -1];\n      }\n    } else if (code === \"KeyA\") {\n      if (\n        (head.direction[0] === 0 && head.direction[1] === 1) ||\n        (head.direction[0] === 0 && head.direction[1] === -1)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [-1, 0],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[1] * -90);\n        head.direction = [-1, 0];\n      }\n    } else if (code === \"KeyD\") {\n      if (\n        (head.direction[0] === 0 && head.direction[1] === 1) ||\n        (head.direction[0] === 0 && head.direction[1] === -1)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [1, 0],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[1] * 90);\n        head.direction = [1, 0];\n      }\n    }\n  });\n};\n\nexport const removeSnakeKeyPressListener = (headRef: any, rotateRef: any) => {\n  window.removeEventListener(\"keypress\", ({ code }) => {\n    const { current: head } = headRef;\n    const { current: rotateList } = rotateRef;\n    if (code === \"KeyW\") {\n      if (\n        (head.direction[0] === 1 && head.direction[1] === 0) ||\n        (head.direction[0] === -1 && head.direction[1] === 0)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [0, 1],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[0] * -90);\n        head.direction = [0, 1];\n      }\n    } else if (code === \"KeyS\") {\n      if (\n        (head.direction[0] === 1 && head.direction[1] === 0) ||\n        (head.direction[0] === -1 && head.direction[1] === 0)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [0, -1],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[0] * 90);\n        head.direction = [0, -1];\n      }\n    } else if (code === \"KeyA\") {\n      if (\n        (head.direction[0] === 0 && head.direction[1] === 1) ||\n        (head.direction[0] === 0 && head.direction[1] === -1)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [-1, 0],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[1] * -90);\n        head.direction = [-1, 0];\n      }\n    } else if (code === \"KeyD\") {\n      if (\n        (head.direction[0] === 0 && head.direction[1] === 1) ||\n        (head.direction[0] === 0 && head.direction[1] === -1)\n      ) {\n        rotateList.push({\n          position: [head.rect.attrs.x - 25, head.rect.attrs.y - 25],\n          direction: [1, 0],\n          segmentsPassed: 0,\n        });\n        head.rect.rotate(head.direction[1] * 90);\n        head.direction = [1, 0];\n      }\n    }\n  });\n};\n","import { Stage } from \"react-konva\"\nimport S from \"./S\";\n\nconst Main = () => {\n    return <Stage width={window.innerWidth} height={window.innerHeight}> \n    <S/>\n    </Stage>\n}\n\nexport default Main;","import './App.css';\nimport Main from './Main';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Main/>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}